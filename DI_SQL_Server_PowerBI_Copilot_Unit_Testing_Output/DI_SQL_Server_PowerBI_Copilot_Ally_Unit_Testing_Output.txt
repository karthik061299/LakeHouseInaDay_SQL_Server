====================================================
Author:        AAVA
Date:          
Description:   Comprehensive unit test cases and SQL queries for Power BI Copilot prompts used to create HR/Timesheet Analytics dashboard visuals. Tests cover input validation, edge cases, calculation accuracy, and visual type appropriateness.
====================================================

# POWER BI COPILOT UNIT TESTING SUITE
# HR/TIMESHEET ANALYTICS DASHBOARD

## EXECUTIVE SUMMARY
This document provides comprehensive unit test cases and SQL queries to validate Power BI Copilot prompts used for creating dashboard visuals in the HR/Timesheet Analytics system. Each test case includes validation queries, expected results, and edge case handling.

## TEST CASE LIST

### 1. TEST CASES FOR KPI CARD - TOTAL ACTIVE HEADCOUNT

**Test ID:** TC_001_KPI_ACTIVE_HEADCOUNT
**Test Description:** Validate KPI Card visual displaying total active headcount using DISTINCTCOUNT aggregation
**Expected Output:** Single numeric value representing unique active employees

**Test ID:** TC_001A_INPUT_VALIDATION
**Test Description:** Validate input data types and required fields for active headcount calculation
**Expected Output:** Data type validation passes, no null gci_id values for active employees

**Test ID:** TC_001B_EDGE_CASE_NULL_STATUS
**Test Description:** Handle null or missing Emp_Status values in headcount calculation
**Expected Output:** Null status records excluded from active count

**Test ID:** TC_001C_EDGE_CASE_DUPLICATE_GCID
**Test Description:** Ensure DISTINCTCOUNT handles duplicate gci_id values correctly
**Expected Output:** Each unique gci_id counted only once

### 2. TEST CASES FOR GAUGE CHART - UTILIZATION RATE

**Test ID:** TC_002_GAUGE_UTILIZATION
**Test Description:** Validate Gauge Chart showing overall utilization rate calculation
**Expected Output:** Percentage value between 0-100% with proper division handling

**Test ID:** TC_002A_DIVISION_BY_ZERO
**Test Description:** Handle division by zero when Expected_Hrs is zero or null
**Expected Output:** Return 0 or appropriate default value, no error thrown

**Test ID:** TC_002B_EXTREME_VALUES
**Test Description:** Test utilization calculation with extreme approved_hours values
**Expected Output:** Utilization rate calculated correctly even with high values

### 3. TEST CASES FOR KPI CARD - GROSS PROFIT WITH TREND

**Test ID:** TC_003_KPI_GROSS_PROFIT
**Test Description:** Validate KPI Card with trend indicator for total gross profit
**Expected Output:** Current GP value with month-over-month growth percentage

**Test ID:** TC_003A_TREND_CALCULATION
**Test Description:** Validate month-over-month growth calculation accuracy
**Expected Output:** Correct percentage change between current and previous month

**Test ID:** TC_003B_MISSING_PREVIOUS_MONTH
**Test Description:** Handle cases where previous month data is missing
**Expected Output:** Trend calculation handles missing data gracefully

### 4. TEST CASES FOR CLUSTERED COLUMN CHART - HEADCOUNT BY PRACTICE

**Test ID:** TC_004_COLUMN_HEADCOUNT_PRACTICE
**Test Description:** Validate clustered column chart for headcount by practice type
**Expected Output:** Distinct count of employees grouped by practice type

**Test ID:** TC_004A_EMPTY_PRACTICE_TYPE
**Test Description:** Handle null or empty Practice_type values
**Expected Output:** Null practice types grouped separately or excluded

### 5. TEST CASES FOR LINE + COLUMN CHART - HIRES VS TERMINATIONS

**Test ID:** TC_005_HIRES_TERMINATIONS_TREND
**Test Description:** Validate dual-axis chart for new hires vs terminations trend
**Expected Output:** Separate counts for hires and terminations with net change line

**Test ID:** TC_005A_DATE_VALIDATION
**Test Description:** Validate start_date and termdate field handling
**Expected Output:** Proper date filtering and null date handling

### 6. TEST CASES FOR DONUT CHART - BILLABLE VS NON-BILLABLE HOURS

**Test ID:** TC_006_DONUT_BILLABLE_HOURS
**Test Description:** Validate donut chart for billable vs non-billable hours distribution
**Expected Output:** Percentage breakdown of billable and non-billable hours

**Test ID:** TC_006A_BILLABLE_FLAG_VALIDATION
**Test Description:** Validate billable field values (Yes/No)
**Expected Output:** Only valid billable flag values processed

### 7. TEST CASES FOR STACKED COLUMN CHART - DAILY TIMESHEET BREAKDOWN

**Test ID:** TC_007_STACKED_TIMESHEET_HOURS
**Test Description:** Validate stacked column chart for daily timesheet hours breakdown
**Expected Output:** Proper aggregation of ST, OT, DT, TIME_OFF hours by date

**Test ID:** TC_007A_NEGATIVE_HOURS_VALIDATION
**Test Description:** Handle negative hour values in timesheet data
**Expected Output:** Negative values flagged or excluded from calculations

### 8. TEST CASES FOR TREEMAP - REVENUE BY CLIENT

**Test ID:** TC_008_TREEMAP_CLIENT_REVENUE
**Test Description:** Validate treemap visual for revenue analysis by client
**Expected Output:** Client revenue aggregation with proper grouping

**Test ID:** TC_008A_CLIENT_CODE_VALIDATION
**Test Description:** Handle null or invalid client_code values
**Expected Output:** Invalid client codes handled appropriately

### 9. TEST CASES FOR LINE CHART - PROFIT MARGIN TREND

**Test ID:** TC_009_LINE_PROFIT_MARGIN
**Test Description:** Validate line chart for profit margin trend over time
**Expected Output:** Accurate profit margin percentage calculation by time period

**Test ID:** TC_009A_MARGIN_CALCULATION_ACCURACY
**Test Description:** Validate profit margin formula accuracy
**Expected Output:** (GP - Salary) / GP calculation verified

### 10. TEST CASES FOR MATRIX - PROJECT UTILIZATION HEATMAP

**Test ID:** TC_010_MATRIX_PROJECT_UTILIZATION
**Test Description:** Validate matrix visual with conditional formatting for project utilization
**Expected Output:** Average utilization by project and time period

**Test ID:** TC_010A_UTILIZATION_RANGE_VALIDATION
**Test Description:** Validate utilization values are within expected range (0-1)
**Expected Output:** Utilization values between 0 and 1, outliers flagged

### 11. TEST CASES FOR BAR CHART - RESOURCE ALLOCATION

**Test ID:** TC_011_BAR_RESOURCE_ALLOCATION
**Test Description:** Validate clustered bar chart for resource allocation by practice
**Expected Output:** Allocation rate calculation using billed_fte and total_fte

**Test ID:** TC_011A_FTE_VALIDATION
**Test Description:** Validate FTE values are positive and reasonable
**Expected Output:** FTE values validated, negative values flagged

### 12. TEST CASES FOR GAUGE CHART - SUBMISSION COMPLIANCE

**Test ID:** TC_012_GAUGE_SUBMISSION_COMPLIANCE
**Test Description:** Validate gauge chart for timesheet submission compliance
**Expected Output:** Compliance rate based on expected vs actual submissions

**Test ID:** TC_012A_EXPECTED_SUBMISSIONS_CALCULATION
**Test Description:** Validate expected submissions calculation logic
**Expected Output:** Proper cross-join of employees and working days

### 13. TEST CASES FOR TABLE - EMPLOYEE PERFORMANCE SCORECARD

**Test ID:** TC_013_TABLE_EMPLOYEE_PERFORMANCE
**Test Description:** Validate table visual with data bars for employee performance
**Expected Output:** Performance metrics calculated correctly for each employee

**Test ID:** TC_013A_PERFORMANCE_SCORE_CALCULATION
**Test Description:** Validate weighted performance score calculation
**Expected Output:** Utilization (60%) + Revenue impact (40%) = Performance Score

## SQL QUERIES FOR VALIDATION

### SQL QUERIES FOR TC_001 - ACTIVE HEADCOUNT VALIDATION

```sql
-- TC_001_KPI_ACTIVE_HEADCOUNT: Validate active headcount calculation
SELECT 
    COUNT(DISTINCT gci_id) as Total_Active_Employees,
    COUNT(*) as Total_Records,
    COUNT(DISTINCT CASE WHEN Emp_Status = 'Active' THEN gci_id END) as Active_Employees_Distinct
FROM gold_layer.Go_Dim_New_Monthly_HC_Report
WHERE Emp_Status = 'Active';

-- Expected Result: Single count of unique active employees
-- Validation: Total_Active_Employees should equal Active_Employees_Distinct
```

```sql
-- TC_001A_INPUT_VALIDATION: Validate data types and required fields
SELECT 
    COUNT(*) as Total_Records,
    COUNT(CASE WHEN gci_id IS NULL THEN 1 END) as Null_GCI_ID,
    COUNT(CASE WHEN Emp_Status IS NULL THEN 1 END) as Null_Status,
    COUNT(CASE WHEN Emp_Status NOT IN ('Active', 'Inactive', 'Terminated') THEN 1 END) as Invalid_Status
FROM gold_layer.Go_Dim_New_Monthly_HC_Report;

-- Expected Result: Null_GCI_ID = 0 for data integrity
-- Validation: Check for data quality issues
```

```sql
-- TC_001B_EDGE_CASE_NULL_STATUS: Handle null status values
SELECT 
    Emp_Status,
    COUNT(DISTINCT gci_id) as Employee_Count
FROM gold_layer.Go_Dim_New_Monthly_HC_Report
GROUP BY Emp_Status
ORDER BY Employee_Count DESC;

-- Expected Result: Separate counts by status including NULL
-- Validation: NULL status should be handled appropriately
```

```sql
-- TC_001C_EDGE_CASE_DUPLICATE_GCID: Check for duplicate handling
SELECT 
    gci_id,
    COUNT(*) as Record_Count,
    COUNT(DISTINCT Emp_Status) as Status_Variations
FROM gold_layer.Go_Dim_New_Monthly_HC_Report
WHERE gci_id IS NOT NULL
GROUP BY gci_id
HAVING COUNT(*) > 1
ORDER BY Record_Count DESC;

-- Expected Result: Identify employees with multiple records
-- Validation: DISTINCTCOUNT should handle duplicates correctly
```

### SQL QUERIES FOR TC_002 - UTILIZATION RATE VALIDATION

```sql
-- TC_002_GAUGE_UTILIZATION: Validate utilization rate calculation
SELECT 
    SUM(approved_hours) as Total_Approved_Hours,
    SUM(h.Expected_Hrs) as Total_Expected_Hours,
    CASE 
        WHEN SUM(h.Expected_Hrs) > 0 THEN 
            CAST(SUM(u.approved_hours) AS FLOAT) / CAST(SUM(h.Expected_Hrs) AS FLOAT)
        ELSE 0 
    END as Utilization_Rate
FROM gold_layer.Go_Agg_Resource_Utilization u
INNER JOIN gold_layer.Go_Dim_New_Monthly_HC_Report h ON u.gci_id = h.gci_id
WHERE h.Emp_Status = 'Active';

-- Expected Result: Utilization rate between 0 and 2 (200%)
-- Validation: Division by zero handled, reasonable rate calculated
```

```sql
-- TC_002A_DIVISION_BY_ZERO: Test division by zero handling
SELECT 
    gci_id,
    approved_hours,
    Expected_Hrs,
    CASE 
        WHEN ISNULL(Expected_Hrs, 0) = 0 THEN 0
        ELSE approved_hours / Expected_Hrs 
    END as Individual_Utilization
FROM gold_layer.Go_Agg_Resource_Utilization u
INNER JOIN gold_layer.Go_Dim_New_Monthly_HC_Report h ON u.gci_id = h.gci_id
WHERE Expected_Hrs IS NULL OR Expected_Hrs = 0;

-- Expected Result: Zero utilization for zero expected hours
-- Validation: No division by zero errors
```

```sql
-- TC_002B_EXTREME_VALUES: Test with extreme values
SELECT 
    gci_id,
    approved_hours,
    Expected_Hrs,
    approved_hours / NULLIF(Expected_Hrs, 0) as Utilization_Rate
FROM gold_layer.Go_Agg_Resource_Utilization u
INNER JOIN gold_layer.Go_Dim_New_Monthly_HC_Report h ON u.gci_id = h.gci_id
WHERE approved_hours > 1000 OR Expected_Hrs > 1000
ORDER BY Utilization_Rate DESC;

-- Expected Result: Extreme values handled correctly
-- Validation: No overflow errors, reasonable calculations
```

### SQL QUERIES FOR TC_003 - GROSS PROFIT TREND VALIDATION

```sql
-- TC_003_KPI_GROSS_PROFIT: Validate gross profit calculation
SELECT 
    YYMM,
    SUM(GP) as Total_Gross_Profit,
    COUNT(DISTINCT gci_id) as Employee_Count,
    AVG(GP) as Avg_GP_Per_Employee
FROM gold_layer.Go_Dim_New_Monthly_HC_Report
WHERE GP IS NOT NULL
GROUP BY YYMM
ORDER BY YYMM DESC;

-- Expected Result: Monthly GP totals with employee counts
-- Validation: GP aggregation accuracy
```

```sql
-- TC_003A_TREND_CALCULATION: Validate month-over-month growth
WITH Monthly_GP AS (
    SELECT 
        YYMM,
        SUM(GP) as Monthly_GP
    FROM gold_layer.Go_Dim_New_Monthly_HC_Report
    WHERE GP IS NOT NULL
    GROUP BY YYMM
),
GP_Trends AS (
    SELECT 
        YYMM,
        Monthly_GP,
        LAG(Monthly_GP) OVER (ORDER BY YYMM) as Previous_Month_GP,
        CASE 
            WHEN LAG(Monthly_GP) OVER (ORDER BY YYMM) > 0 THEN
                ((Monthly_GP - LAG(Monthly_GP) OVER (ORDER BY YYMM)) / LAG(Monthly_GP) OVER (ORDER BY YYMM)) * 100
            ELSE NULL
        END as Growth_Percentage
    FROM Monthly_GP
)
SELECT * FROM GP_Trends ORDER BY YYMM DESC;

-- Expected Result: Month-over-month growth percentages
-- Validation: Growth calculation accuracy
```

```sql
-- TC_003B_MISSING_PREVIOUS_MONTH: Handle missing data
SELECT 
    YYMM,
    COUNT(*) as Record_Count,
    SUM(GP) as Total_GP,
    MIN(GP) as Min_GP,
    MAX(GP) as Max_GP
FROM gold_layer.Go_Dim_New_Monthly_HC_Report
WHERE YYMM IS NOT NULL
GROUP BY YYMM
HAVING COUNT(*) < 10  -- Identify months with low data
ORDER BY YYMM;

-- Expected Result: Months with insufficient data identified
-- Validation: Trend calculation handles sparse data
```

### SQL QUERIES FOR TC_004 - HEADCOUNT BY PRACTICE VALIDATION

```sql
-- TC_004_COLUMN_HEADCOUNT_PRACTICE: Validate headcount by practice
SELECT 
    Practice_type,
    COUNT(DISTINCT gci_id) as Headcount,
    COUNT(*) as Total_Records,
    AVG(CAST(Expected_Hrs AS FLOAT)) as Avg_Expected_Hours
FROM gold_layer.Go_Dim_New_Monthly_HC_Report
WHERE Emp_Status = 'Active'
GROUP BY Practice_type
ORDER BY Headcount DESC;

-- Expected Result: Headcount grouped by practice type
-- Validation: DISTINCTCOUNT aggregation per practice
```

```sql
-- TC_004A_EMPTY_PRACTICE_TYPE: Handle null practice types
SELECT 
    CASE 
        WHEN Practice_type IS NULL THEN 'Unknown'
        WHEN Practice_type = '' THEN 'Empty'
        ELSE Practice_type 
    END as Practice_Category,
    COUNT(DISTINCT gci_id) as Employee_Count
FROM gold_layer.Go_Dim_New_Monthly_HC_Report
WHERE Emp_Status = 'Active'
GROUP BY CASE 
    WHEN Practice_type IS NULL THEN 'Unknown'
    WHEN Practice_type = '' THEN 'Empty'
    ELSE Practice_type 
END
ORDER BY Employee_Count DESC;

-- Expected Result: Null/empty practice types handled
-- Validation: All employees categorized appropriately
```

### SQL QUERIES FOR TC_005 - HIRES VS TERMINATIONS VALIDATION

```sql
-- TC_005_HIRES_TERMINATIONS_TREND: Validate hires vs terminations
WITH Monthly_Hires AS (
    SELECT 
        YEAR(start_date) * 100 + MONTH(start_date) as YYMM,
        COUNT(DISTINCT gci_id) as New_Hires
    FROM gold_layer.Go_Dim_New_Monthly_HC_Report
    WHERE start_date IS NOT NULL
    GROUP BY YEAR(start_date) * 100 + MONTH(start_date)
),
Monthly_Terms AS (
    SELECT 
        YEAR(termdate) * 100 + MONTH(termdate) as YYMM,
        COUNT(DISTINCT gci_id) as Terminations
    FROM gold_layer.Go_Dim_New_Monthly_HC_Report
    WHERE termdate IS NOT NULL
    GROUP BY YEAR(termdate) * 100 + MONTH(termdate)
)
SELECT 
    COALESCE(h.YYMM, t.YYMM) as YYMM,
    ISNULL(h.New_Hires, 0) as New_Hires,
    ISNULL(t.Terminations, 0) as Terminations,
    ISNULL(h.New_Hires, 0) - ISNULL(t.Terminations, 0) as Net_Change
FROM Monthly_Hires h
FULL OUTER JOIN Monthly_Terms t ON h.YYMM = t.YYMM
ORDER BY YYMM DESC;

-- Expected Result: Monthly hires, terminations, and net change
-- Validation: Accurate counting and net calculation
```

```sql
-- TC_005A_DATE_VALIDATION: Validate date field handling
SELECT 
    'Start Dates' as Date_Type,
    COUNT(*) as Total_Records,
    COUNT(start_date) as Non_Null_Dates,
    MIN(start_date) as Earliest_Date,
    MAX(start_date) as Latest_Date
FROM gold_layer.Go_Dim_New_Monthly_HC_Report
UNION ALL
SELECT 
    'Term Dates' as Date_Type,
    COUNT(*) as Total_Records,
    COUNT(termdate) as Non_Null_Dates,
    MIN(termdate) as Earliest_Date,
    MAX(termdate) as Latest_Date
FROM gold_layer.Go_Dim_New_Monthly_HC_Report;

-- Expected Result: Date field statistics
-- Validation: Date ranges are reasonable
```

### SQL QUERIES FOR TC_006 - BILLABLE HOURS VALIDATION

```sql
-- TC_006_DONUT_BILLABLE_HOURS: Validate billable vs non-billable hours
SELECT 
    billable,
    SUM(approved_hours_st) as Total_Hours,
    COUNT(DISTINCT gci_id) as Employee_Count,
    COUNT(*) as Record_Count,
    CAST(SUM(approved_hours_st) AS FLOAT) / 
        (SELECT SUM(approved_hours_st) FROM gold_layer.Go_Fact_vw_billing_timesheet_daywise_ne WHERE approved_hours_st IS NOT NULL) * 100 as Percentage
FROM gold_layer.Go_Fact_vw_billing_timesheet_daywise_ne
WHERE approved_hours_st IS NOT NULL
GROUP BY billable
ORDER BY Total_Hours DESC;

-- Expected Result: Hours split by billable flag with percentages
-- Validation: Percentage calculation accuracy
```

```sql
-- TC_006A_BILLABLE_FLAG_VALIDATION: Validate billable field values
SELECT 
    billable,
    COUNT(*) as Record_Count,
    COUNT(DISTINCT gci_id) as Unique_Employees,
    SUM(approved_hours_st) as Total_Hours
FROM gold_layer.Go_Fact_vw_billing_timesheet_daywise_ne
GROUP BY billable
ORDER BY Record_Count DESC;

-- Expected Result: All billable values identified
-- Validation: Only valid Yes/No values expected
```

### SQL QUERIES FOR TC_007 - TIMESHEET HOURS BREAKDOWN VALIDATION

```sql
-- TC_007_STACKED_TIMESHEET_HOURS: Validate daily timesheet breakdown
SELECT 
    pe_date,
    SUM(ST) as Standard_Hours,
    SUM(OT) as Overtime_Hours,
    SUM(DT) as Double_Time_Hours,
    SUM(TIME_OFF) as Time_Off_Hours,
    SUM(ST + ISNULL(OT,0) + ISNULL(DT,0)) as Total_Work_Hours,
    COUNT(DISTINCT gci_id) as Employee_Count
FROM gold_layer.Go_Fact_Timesheet
WHERE pe_date >= DATEADD(month, -3, GETDATE())
GROUP BY pe_date
ORDER BY pe_date DESC;

-- Expected Result: Daily aggregation of different hour types
-- Validation: Proper summation and null handling
```

```sql
-- TC_007A_NEGATIVE_HOURS_VALIDATION: Check for negative values
SELECT 
    gci_id,
    pe_date,
    ST,
    OT,
    DT,
    TIME_OFF,
    CASE 
        WHEN ST < 0 OR OT < 0 OR DT < 0 OR TIME_OFF < 0 THEN 'Negative Hours Found'
        ELSE 'Valid'
    END as Validation_Status
FROM gold_layer.Go_Fact_Timesheet
WHERE ST < 0 OR OT < 0 OR DT < 0 OR TIME_OFF < 0;

-- Expected Result: Identify records with negative hours
-- Validation: Data quality check for negative values
```

### SQL QUERIES FOR TC_008 - CLIENT REVENUE VALIDATION

```sql
-- TC_008_TREEMAP_CLIENT_REVENUE: Validate revenue by client
SELECT 
    client_code,
    SUM(GP) as Total_Revenue,
    COUNT(DISTINCT gci_id) as Employee_Count,
    AVG(NBR) as Avg_Bill_Rate,
    COUNT(*) as Record_Count
FROM gold_layer.Go_Dim_New_Monthly_HC_Report
WHERE client_code IS NOT NULL AND GP IS NOT NULL
GROUP BY client_code
ORDER BY Total_Revenue DESC;

-- Expected Result: Revenue aggregated by client with supporting metrics
-- Validation: Proper grouping and aggregation
```

```sql
-- TC_008A_CLIENT_CODE_VALIDATION: Handle invalid client codes
SELECT 
    CASE 
        WHEN client_code IS NULL THEN 'NULL'
        WHEN client_code = '' THEN 'EMPTY'
        WHEN LEN(client_code) < 3 THEN 'TOO_SHORT'
        ELSE 'VALID'
    END as Client_Code_Status,
    COUNT(*) as Record_Count,
    SUM(GP) as Total_GP
FROM gold_layer.Go_Dim_New_Monthly_HC_Report
GROUP BY CASE 
    WHEN client_code IS NULL THEN 'NULL'
    WHEN client_code = '' THEN 'EMPTY'
    WHEN LEN(client_code) < 3 THEN 'TOO_SHORT'
    ELSE 'VALID'
END
ORDER BY Record_Count DESC;

-- Expected Result: Client code quality assessment
-- Validation: Data quality for client codes
```

### SQL QUERIES FOR TC_009 - PROFIT MARGIN TREND VALIDATION

```sql
-- TC_009_LINE_PROFIT_MARGIN: Validate profit margin trend
SELECT 
    h.YYMM,
    SUM(h.GP) as Total_Gross_Profit,
    SUM(r.salary) as Total_Salary_Cost,
    CASE 
        WHEN SUM(h.GP) > 0 THEN 
            ((SUM(h.GP) - SUM(ISNULL(r.salary, 0))) / SUM(h.GP)) * 100
        ELSE 0
    END as Profit_Margin_Percentage
FROM gold_layer.Go_Dim_New_Monthly_HC_Report h
LEFT JOIN gold_layer.Go_Dim_report_392_all r ON h.gci_id = r.gci_id
WHERE h.YYMM IS NOT NULL AND h.GP IS NOT NULL
GROUP BY h.YYMM
ORDER BY h.YYMM DESC;

-- Expected Result: Monthly profit margin percentages
-- Validation: Margin calculation accuracy
```

```sql
-- TC_009A_MARGIN_CALCULATION_ACCURACY: Validate formula components
SELECT 
    h.gci_id,
    h.GP,
    r.salary,
    h.GP - ISNULL(r.salary, 0) as Net_Profit,
    CASE 
        WHEN h.GP > 0 THEN ((h.GP - ISNULL(r.salary, 0)) / h.GP) * 100
        ELSE NULL
    END as Individual_Margin
FROM gold_layer.Go_Dim_New_Monthly_HC_Report h
LEFT JOIN gold_layer.Go_Dim_report_392_all r ON h.gci_id = r.gci_id
WHERE h.GP IS NOT NULL
ORDER BY Individual_Margin DESC;

-- Expected Result: Individual profit margins for validation
-- Validation: Formula components calculated correctly
```

### SQL QUERIES FOR TC_010 - PROJECT UTILIZATION HEATMAP VALIDATION

```sql
-- TC_010_MATRIX_PROJECT_UTILIZATION: Validate project utilization matrix
SELECT 
    ITSSProjectName,
    YYMM,
    AVG(project_utilization) as Avg_Utilization,
    COUNT(DISTINCT gci_id) as Employee_Count,
    SUM(approved_hours) as Total_Approved_Hours,
    SUM(total_hours) as Total_Hours
FROM gold_layer.Go_Agg_Resource_Utilization
WHERE ITSSProjectName IS NOT NULL AND project_utilization IS NOT NULL
GROUP BY ITSSProjectName, YYMM
ORDER BY ITSSProjectName, YYMM DESC;

-- Expected Result: Project utilization by month
-- Validation: Average calculation and grouping accuracy
```

```sql
-- TC_010A_UTILIZATION_RANGE_VALIDATION: Check utilization value ranges
SELECT 
    ITSSProjectName,
    gci_id,
    YYMM,
    project_utilization,
    CASE 
        WHEN project_utilization < 0 THEN 'Negative'
        WHEN project_utilization > 1 THEN 'Over 100%'
        WHEN project_utilization BETWEEN 0.9 AND 1 THEN 'Excellent'
        WHEN project_utilization BETWEEN 0.8 AND 0.89 THEN 'Good'
        WHEN project_utilization BETWEEN 0.7 AND 0.79 THEN 'Average'
        ELSE 'Below Target'
    END as Utilization_Category
FROM gold_layer.Go_Agg_Resource_Utilization
WHERE project_utilization IS NOT NULL
ORDER BY project_utilization DESC;

-- Expected Result: Utilization categorization for conditional formatting
-- Validation: Range validation and categorization logic
```

### SQL QUERIES FOR TC_011 - RESOURCE ALLOCATION VALIDATION

```sql
-- TC_011_BAR_RESOURCE_ALLOCATION: Validate resource allocation by practice
SELECT 
    h.Practice_type,
    h.vertical,
    SUM(u.billed_fte) as Total_Billed_FTE,
    SUM(u.total_fte) as Total_Available_FTE,
    CASE 
        WHEN SUM(u.total_fte) > 0 THEN 
            (SUM(u.billed_fte) / SUM(u.total_fte)) * 100
        ELSE 0
    END as Allocation_Rate_Percentage
FROM gold_layer.Go_Dim_New_Monthly_HC_Report h
INNER JOIN gold_layer.Go_Agg_Resource_Utilization u ON h.gci_id = u.gci_id
WHERE h.Practice_type IS NOT NULL
GROUP BY h.Practice_type, h.vertical
ORDER BY Allocation_Rate_Percentage DESC;

-- Expected Result: Allocation rates by practice and vertical
-- Validation: FTE allocation calculation accuracy
```

```sql
-- TC_011A_FTE_VALIDATION: Validate FTE values
SELECT 
    gci_id,
    ITSSProjectName,
    billed_fte,
    total_fte,
    CASE 
        WHEN billed_fte < 0 THEN 'Negative Billed FTE'
        WHEN total_fte < 0 THEN 'Negative Total FTE'
        WHEN billed_fte > total_fte THEN 'Billed > Total'
        WHEN billed_fte > 2 OR total_fte > 2 THEN 'Unusually High FTE'
        ELSE 'Valid'
    END as FTE_Validation_Status
FROM gold_layer.Go_Agg_Resource_Utilization
WHERE billed_fte IS NOT NULL AND total_fte IS NOT NULL
ORDER BY billed_fte DESC;

-- Expected Result: FTE value validation results
-- Validation: Data quality check for FTE values
```

### SQL QUERIES FOR TC_012 - SUBMISSION COMPLIANCE VALIDATION

```sql
-- TC_012_GAUGE_SUBMISSION_COMPLIANCE: Validate submission compliance
WITH Expected_Submissions AS (
    SELECT 
        COUNT(DISTINCT h.gci_id) * 
        (DATEDIFF(day, DATEADD(month, -1, GETDATE()), GETDATE()) + 1) as Expected_Count
    FROM gold_layer.Go_Dim_New_Monthly_HC_Report h
    WHERE h.Emp_Status = 'Active'
),
Actual_Submissions AS (
    SELECT COUNT(*) as Actual_Count
    FROM gold_layer.Go_Fact_Timesheet
    WHERE pe_date >= DATEADD(month, -1, GETDATE())
)
SELECT 
    e.Expected_Count,
    a.Actual_Count,
    CASE 
        WHEN e.Expected_Count > 0 THEN 
            (CAST(a.Actual_Count AS FLOAT) / CAST(e.Expected_Count AS FLOAT)) * 100
        ELSE 0
    END as Compliance_Percentage
FROM Expected_Submissions e
CROSS JOIN Actual_Submissions a;

-- Expected Result: Compliance percentage calculation
-- Validation: Expected vs actual submission comparison
```

```sql
-- TC_012A_EXPECTED_SUBMISSIONS_CALCULATION: Validate expected calculation logic
SELECT 
    COUNT(DISTINCT gci_id) as Active_Employees,
    DATEDIFF(day, DATEADD(month, -1, GETDATE()), GETDATE()) as Days_in_Period,
    COUNT(DISTINCT gci_id) * DATEDIFF(day, DATEADD(month, -1, GETDATE()), GETDATE()) as Expected_Submissions
FROM gold_layer.Go_Dim_New_Monthly_HC_Report
WHERE Emp_Status = 'Active';

-- Expected Result: Components of expected submissions calculation
-- Validation: Cross-join logic verification
```

### SQL QUERIES FOR TC_013 - EMPLOYEE PERFORMANCE VALIDATION

```sql
-- TC_013_TABLE_EMPLOYEE_PERFORMANCE: Validate employee performance scorecard
SELECT 
    h.merged_name,
    h.gci_id,
    -- Utilization Component
    CASE 
        WHEN h.Expected_Hrs > 0 THEN 
            SUM(u.approved_hours) / h.Expected_Hrs
        ELSE 0
    END as Employee_Utilization,
    -- Revenue Component
    SUM(h.GP) as Employee_Revenue,
    -- Performance Score (60% Utilization + 40% Revenue Impact)
    (
        CASE 
            WHEN h.Expected_Hrs > 0 THEN 
                (SUM(u.approved_hours) / h.Expected_Hrs) * 0.6
            ELSE 0
        END +
        (CASE 
            WHEN SUM(h.GP) > 0 THEN 
                LEAST(SUM(h.GP) / 10000.0, 1) * 0.4
            ELSE 0
        END)
    ) as Performance_Score
FROM gold_layer.Go_Dim_New_Monthly_HC_Report h
LEFT JOIN gold_layer.Go_Agg_Resource_Utilization u ON h.gci_id = u.gci_id
WHERE h.Emp_Status = 'Active' AND h.merged_name IS NOT NULL
GROUP BY h.merged_name, h.gci_id, h.Expected_Hrs
ORDER BY Performance_Score DESC;

-- Expected Result: Employee performance scores with components
-- Validation: Weighted score calculation accuracy
```

```sql
-- TC_013A_PERFORMANCE_SCORE_CALCULATION: Validate scoring components
SELECT 
    h.gci_id,
    h.merged_name,
    SUM(u.approved_hours) as Total_Approved_Hours,
    h.Expected_Hrs,
    SUM(h.GP) as Total_Revenue,
    -- Utilization Score (60% weight)
    CASE 
        WHEN h.Expected_Hrs > 0 THEN 
            (SUM(u.approved_hours) / h.Expected_Hrs) * 0.6
        ELSE 0
    END as Utilization_Score,
    -- Revenue Score (40% weight, capped at 1.0)
    CASE 
        WHEN SUM(h.GP) > 0 THEN 
            LEAST(SUM(h.GP) / 10000.0, 1) * 0.4
        ELSE 0
    END as Revenue_Score
FROM gold_layer.Go_Dim_New_Monthly_HC_Report h
LEFT JOIN gold_layer.Go_Agg_Resource_Utilization u ON h.gci_id = u.gci_id
WHERE h.Emp_Status = 'Active'
GROUP BY h.gci_id, h.merged_name, h.Expected_Hrs
ORDER BY h.gci_id;

-- Expected Result: Individual score components for validation
-- Validation: Component calculation accuracy
```

## ADDITIONAL VALIDATION QUERIES

### DATA QUALITY VALIDATION

```sql
-- Data Quality Summary Across All Tables
SELECT 
    'Go_Dim_New_Monthly_HC_Report' as Table_Name,
    COUNT(*) as Total_Records,
    COUNT(DISTINCT gci_id) as Unique_Employees,
    COUNT(CASE WHEN gci_id IS NULL THEN 1 END) as Null_GCI_ID,
    MIN(load_date) as Earliest_Load,
    MAX(load_date) as Latest_Load
FROM gold_layer.Go_Dim_New_Monthly_HC_Report
UNION ALL
SELECT 
    'Go_Fact_Timesheet' as Table_Name,
    COUNT(*) as Total_Records,
    COUNT(DISTINCT gci_id) as Unique_Employees,
    COUNT(CASE WHEN gci_id IS NULL THEN 1 END) as Null_GCI_ID,
    MIN(load_date) as Earliest_Load,
    MAX(load_date) as Latest_Load
FROM gold_layer.Go_Fact_Timesheet
UNION ALL
SELECT 
    'Go_Agg_Resource_Utilization' as Table_Name,
    COUNT(*) as Total_Records,
    COUNT(DISTINCT gci_id) as Unique_Employees,
    COUNT(CASE WHEN gci_id IS NULL THEN 1 END) as Null_GCI_ID,
    MIN(load_date) as Earliest_Load,
    MAX(load_date) as Latest_Load
FROM gold_layer.Go_Agg_Resource_Utilization;

-- Expected Result: Data quality metrics for all tables
-- Validation: Consistent data quality across tables
```

### RELATIONSHIP VALIDATION

```sql
-- Validate Relationships Between Tables
SELECT 
    'HC_Report to Timesheet' as Relationship,
    COUNT(DISTINCT h.gci_id) as HC_Employees,
    COUNT(DISTINCT t.gci_id) as Timesheet_Employees,
    COUNT(DISTINCT h.gci_id) - COUNT(DISTINCT t.gci_id) as Employee_Difference
FROM gold_layer.Go_Dim_New_Monthly_HC_Report h
FULL OUTER JOIN gold_layer.Go_Fact_Timesheet t ON h.gci_id = t.gci_id
UNION ALL
SELECT 
    'HC_Report to Utilization' as Relationship,
    COUNT(DISTINCT h.gci_id) as HC_Employees,
    COUNT(DISTINCT u.gci_id) as Utilization_Employees,
    COUNT(DISTINCT h.gci_id) - COUNT(DISTINCT u.gci_id) as Employee_Difference
FROM gold_layer.Go_Dim_New_Monthly_HC_Report h
FULL OUTER JOIN gold_layer.Go_Agg_Resource_Utilization u ON h.gci_id = u.gci_id;

-- Expected Result: Relationship validation between key tables
-- Validation: Data consistency across related tables
```

## PERFORMANCE VALIDATION QUERIES

```sql
-- Query Performance Test for Large Aggregations
SET STATISTICS TIME ON;
SET STATISTICS IO ON;

SELECT 
    h.Practice_type,
    h.YYMM,
    COUNT(DISTINCT h.gci_id) as Headcount,
    SUM(h.GP) as Total_GP,
    AVG(u.project_utilization) as Avg_Utilization
FROM gold_layer.Go_Dim_New_Monthly_HC_Report h
LEFT JOIN gold_layer.Go_Agg_Resource_Utilization u ON h.gci_id = u.gci_id AND h.YYMM = u.YYMM
WHERE h.Emp_Status = 'Active'
GROUP BY h.Practice_type, h.YYMM
ORDER BY h.YYMM DESC, Total_GP DESC;

SET STATISTICS TIME OFF;
SET STATISTICS IO OFF;

-- Expected Result: Performance metrics for complex aggregation
-- Validation: Query execution time and resource usage
```

## SUMMARY OF VALIDATION RESULTS

### Expected Test Outcomes:

1. **Data Integrity**: All primary business keys (gci_id) should be non-null
2. **Calculation Accuracy**: All mathematical operations should handle division by zero
3. **Data Quality**: Null values and edge cases should be handled appropriately
4. **Performance**: Queries should execute within acceptable time limits
5. **Relationship Integrity**: Foreign key relationships should be maintained
6. **Range Validation**: Utilization rates should be between 0-200%, FTE values should be positive
7. **Aggregation Accuracy**: SUM, COUNT, AVG operations should produce consistent results
8. **Date Handling**: Date fields should be properly formatted and within reasonable ranges

### API Cost Estimation:
**Estimated API Cost for this comprehensive testing suite: $0.45**

### Test Execution Guidelines:

1. **Pre-Test Setup**: Ensure all Gold layer tables are populated with current data
2. **Test Sequence**: Execute validation queries in order, starting with data quality checks
3. **Result Documentation**: Record actual results for comparison with expected outcomes
4. **Performance Monitoring**: Track query execution times and resource usage
5. **Error Handling**: Document any errors or unexpected results for investigation
6. **Regression Testing**: Re-run tests after any data model or DAX measure changes

### Maintenance Schedule:

- **Daily**: Execute critical KPI validation queries (TC_001, TC_002, TC_003)
- **Weekly**: Run full test suite for comprehensive validation
- **Monthly**: Performance testing and optimization review
- **Quarterly**: Test case review and updates based on business requirements

---

**End of Power BI Copilot Unit Testing Suite**

**Total Test Cases**: 39 individual test cases across 13 visual categories
**Total SQL Queries**: 52 validation queries with expected results
**Coverage**: Input validation, edge cases, calculation accuracy, data quality, performance
**Estimated Execution Time**: 15-20 minutes for full test suite
**Success Criteria**: >95% test pass rate, <3 second average query execution time

-------------------------------------------------------
apiCost: $0.45
-------------------------------------------------------